// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 25.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `network.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.RemoteNode)
pub struct RemoteNode {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.RemoteNode.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.RemoteNode.addr)
    pub addr: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.RemoteNode.node_started_at)
    pub node_started_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:coerce.network.RemoteNode.tag)
    pub tag: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.RemoteNode.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.RemoteNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoteNode {
    fn default() -> &'a RemoteNode {
        <RemoteNode as ::protobuf::Message>::default_instance()
    }
}

impl RemoteNode {
    pub fn new() -> RemoteNode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &RemoteNode| { &m.node_id },
            |m: &mut RemoteNode| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addr",
            |m: &RemoteNode| { &m.addr },
            |m: &mut RemoteNode| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "node_started_at",
            |m: &RemoteNode| { &m.node_started_at },
            |m: &mut RemoteNode| { &mut m.node_started_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tag",
            |m: &RemoteNode| { &m.tag },
            |m: &mut RemoteNode| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &RemoteNode| { &m.attributes },
            |m: &mut RemoteNode| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoteNode>(
            "RemoteNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoteNode {
    const NAME: &'static str = "RemoteNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_uint64()?;
                },
                18 => {
                    self.addr = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node_started_at)?;
                },
                34 => {
                    self.tag = is.read_string()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.node_id);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        if let Some(v) = self.node_started_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tag);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        if let Some(v) = self.node_started_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.tag.is_empty() {
            os.write_string(4, &self.tag)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoteNode {
        RemoteNode::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.addr.clear();
        self.node_started_at.clear();
        self.tag.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoteNode {
        static instance: ::protobuf::rt::Lazy<RemoteNode> = ::protobuf::rt::Lazy::new();
        instance.get(RemoteNode::new)
    }
}

impl ::protobuf::MessageFull for RemoteNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoteNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoteNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.IdentifyEvent)
pub struct IdentifyEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.IdentifyEvent.source_node_id)
    pub source_node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.IdentifyEvent.source_node_tag)
    pub source_node_tag: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.IdentifyEvent.token)
    pub token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.IdentifyEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdentifyEvent {
    fn default() -> &'a IdentifyEvent {
        <IdentifyEvent as ::protobuf::Message>::default_instance()
    }
}

impl IdentifyEvent {
    pub fn new() -> IdentifyEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_node_id",
            |m: &IdentifyEvent| { &m.source_node_id },
            |m: &mut IdentifyEvent| { &mut m.source_node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_node_tag",
            |m: &IdentifyEvent| { &m.source_node_tag },
            |m: &mut IdentifyEvent| { &mut m.source_node_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &IdentifyEvent| { &m.token },
            |m: &mut IdentifyEvent| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdentifyEvent>(
            "IdentifyEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdentifyEvent {
    const NAME: &'static str = "IdentifyEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_node_id = is.read_uint64()?;
                },
                18 => {
                    self.source_node_tag = is.read_string()?;
                },
                26 => {
                    self.token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.source_node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.source_node_id);
        }
        if !self.source_node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_node_tag);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.source_node_id != 0 {
            os.write_uint64(1, self.source_node_id)?;
        }
        if !self.source_node_tag.is_empty() {
            os.write_string(2, &self.source_node_tag)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdentifyEvent {
        IdentifyEvent::new()
    }

    fn clear(&mut self) {
        self.source_node_id = 0;
        self.source_node_tag.clear();
        self.token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdentifyEvent {
        static instance: IdentifyEvent = IdentifyEvent {
            source_node_id: 0,
            source_node_tag: ::std::string::String::new(),
            token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdentifyEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdentifyEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdentifyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifyEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.NodeIdentity)
pub struct NodeIdentity {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.node_tag)
    pub node_tag: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.addr)
    pub addr: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.application_version)
    pub application_version: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.protocol_version)
    pub protocol_version: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.node_started_at)
    pub node_started_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.peers)
    pub peers: ::std::vec::Vec<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.capabilities)
    pub capabilities: ::protobuf::MessageField<SystemCapabilities>,
    // @@protoc_insertion_point(field:coerce.network.NodeIdentity.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.NodeIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeIdentity {
    fn default() -> &'a NodeIdentity {
        <NodeIdentity as ::protobuf::Message>::default_instance()
    }
}

impl NodeIdentity {
    pub fn new() -> NodeIdentity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &NodeIdentity| { &m.node_id },
            |m: &mut NodeIdentity| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_tag",
            |m: &NodeIdentity| { &m.node_tag },
            |m: &mut NodeIdentity| { &mut m.node_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addr",
            |m: &NodeIdentity| { &m.addr },
            |m: &mut NodeIdentity| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "application_version",
            |m: &NodeIdentity| { &m.application_version },
            |m: &mut NodeIdentity| { &mut m.application_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_version",
            |m: &NodeIdentity| { &m.protocol_version },
            |m: &mut NodeIdentity| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "node_started_at",
            |m: &NodeIdentity| { &m.node_started_at },
            |m: &mut NodeIdentity| { &mut m.node_started_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peers",
            |m: &NodeIdentity| { &m.peers },
            |m: &mut NodeIdentity| { &mut m.peers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SystemCapabilities>(
            "capabilities",
            |m: &NodeIdentity| { &m.capabilities },
            |m: &mut NodeIdentity| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &NodeIdentity| { &m.attributes },
            |m: &mut NodeIdentity| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeIdentity>(
            "NodeIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeIdentity {
    const NAME: &'static str = "NodeIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_uint64()?;
                },
                18 => {
                    self.node_tag = is.read_string()?;
                },
                26 => {
                    self.addr = is.read_string()?;
                },
                34 => {
                    self.application_version = is.read_string()?;
                },
                42 => {
                    self.protocol_version = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node_started_at)?;
                },
                58 => {
                    self.peers.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.node_id);
        }
        if !self.node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.node_tag);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.addr);
        }
        if !self.application_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.application_version);
        }
        if !self.protocol_version.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.protocol_version);
        }
        if let Some(v) = self.node_started_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.node_tag.is_empty() {
            os.write_string(2, &self.node_tag)?;
        }
        if !self.addr.is_empty() {
            os.write_string(3, &self.addr)?;
        }
        if !self.application_version.is_empty() {
            os.write_string(4, &self.application_version)?;
        }
        if !self.protocol_version.is_empty() {
            os.write_string(5, &self.protocol_version)?;
        }
        if let Some(v) = self.node_started_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.peers {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeIdentity {
        NodeIdentity::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.node_tag.clear();
        self.addr.clear();
        self.application_version.clear();
        self.protocol_version.clear();
        self.node_started_at.clear();
        self.peers.clear();
        self.capabilities.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeIdentity {
        static instance: ::protobuf::rt::Lazy<NodeIdentity> = ::protobuf::rt::Lazy::new();
        instance.get(NodeIdentity::new)
    }
}

impl ::protobuf::MessageFull for NodeIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.SystemCapabilities)
pub struct SystemCapabilities {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.SystemCapabilities.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:coerce.network.SystemCapabilities.messages)
    pub messages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.SystemCapabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SystemCapabilities {
    fn default() -> &'a SystemCapabilities {
        <SystemCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl SystemCapabilities {
    pub fn new() -> SystemCapabilities {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actors",
            |m: &SystemCapabilities| { &m.actors },
            |m: &mut SystemCapabilities| { &mut m.actors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &SystemCapabilities| { &m.messages },
            |m: &mut SystemCapabilities| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SystemCapabilities>(
            "SystemCapabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SystemCapabilities {
    const NAME: &'static str = "SystemCapabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                18 => {
                    self.messages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.messages {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        for v in &self.messages {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SystemCapabilities {
        SystemCapabilities::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SystemCapabilities {
        static instance: SystemCapabilities = SystemCapabilities {
            actors: ::std::vec::Vec::new(),
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SystemCapabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SystemCapabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SystemCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemCapabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.ClientHandshake)
pub struct ClientHandshake {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.ClientHandshake.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.ClientHandshake.nodes)
    pub nodes: ::std::vec::Vec<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.ClientHandshake.node_tag)
    pub node_tag: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ClientHandshake.trace_id)
    pub trace_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ClientHandshake.node_started_at)
    pub node_started_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.ClientHandshake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientHandshake {
    fn default() -> &'a ClientHandshake {
        <ClientHandshake as ::protobuf::Message>::default_instance()
    }
}

impl ClientHandshake {
    pub fn new() -> ClientHandshake {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &ClientHandshake| { &m.node_id },
            |m: &mut ClientHandshake| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &ClientHandshake| { &m.nodes },
            |m: &mut ClientHandshake| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_tag",
            |m: &ClientHandshake| { &m.node_tag },
            |m: &mut ClientHandshake| { &mut m.node_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &ClientHandshake| { &m.trace_id },
            |m: &mut ClientHandshake| { &mut m.trace_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "node_started_at",
            |m: &ClientHandshake| { &m.node_started_at },
            |m: &mut ClientHandshake| { &mut m.node_started_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientHandshake>(
            "ClientHandshake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientHandshake {
    const NAME: &'static str = "ClientHandshake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_uint64()?;
                },
                18 => {
                    self.nodes.push(is.read_message()?);
                },
                26 => {
                    self.node_tag = is.read_string()?;
                },
                34 => {
                    self.trace_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node_started_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.node_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_tag);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trace_id);
        }
        if let Some(v) = self.node_started_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.node_tag.is_empty() {
            os.write_string(3, &self.node_tag)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(4, &self.trace_id)?;
        }
        if let Some(v) = self.node_started_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientHandshake {
        ClientHandshake::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.nodes.clear();
        self.node_tag.clear();
        self.trace_id.clear();
        self.node_started_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientHandshake {
        static instance: ClientHandshake = ClientHandshake {
            node_id: 0,
            nodes: ::std::vec::Vec::new(),
            node_tag: ::std::string::String::new(),
            trace_id: ::std::string::String::new(),
            node_started_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientHandshake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientHandshake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientHandshake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.ClientResult)
pub struct ClientResult {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.ClientResult.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ClientResult.result)
    pub result: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:coerce.network.ClientResult.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.ClientResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientResult {
    fn default() -> &'a ClientResult {
        <ClientResult as ::protobuf::Message>::default_instance()
    }
}

impl ClientResult {
    pub fn new() -> ClientResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &ClientResult| { &m.message_id },
            |m: &mut ClientResult| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &ClientResult| { &m.result },
            |m: &mut ClientResult| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &ClientResult| { &m.trace_id },
            |m: &mut ClientResult| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientResult>(
            "ClientResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientResult {
    const NAME: &'static str = "ClientResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.result = is.read_bytes()?;
                },
                26 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.result);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.result.is_empty() {
            os.write_bytes(2, &self.result)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientResult {
        ClientResult::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.result.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientResult {
        static instance: ClientResult = ClientResult {
            message_id: ::std::string::String::new(),
            result: ::std::vec::Vec::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.ClientErr)
pub struct ClientErr {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.ClientErr.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ClientErr.error)
    pub error: ::protobuf::MessageField<ActorRefErr>,
    // @@protoc_insertion_point(field:coerce.network.ClientErr.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.ClientErr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientErr {
    fn default() -> &'a ClientErr {
        <ClientErr as ::protobuf::Message>::default_instance()
    }
}

impl ClientErr {
    pub fn new() -> ClientErr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &ClientErr| { &m.message_id },
            |m: &mut ClientErr| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActorRefErr>(
            "error",
            |m: &ClientErr| { &m.error },
            |m: &mut ClientErr| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &ClientErr| { &m.trace_id },
            |m: &mut ClientErr| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientErr>(
            "ClientErr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientErr {
    const NAME: &'static str = "ClientErr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error)?;
                },
                26 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientErr {
        ClientErr::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.error.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientErr {
        static instance: ClientErr = ClientErr {
            message_id: ::std::string::String::new(),
            error: ::protobuf::MessageField::none(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientErr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientErr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientErr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientErr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.PingEvent)
pub struct PingEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.PingEvent.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.PingEvent.trace_id)
    pub trace_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.PingEvent.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.PingEvent.system_terminated)
    pub system_terminated: bool,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.PingEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingEvent {
    fn default() -> &'a PingEvent {
        <PingEvent as ::protobuf::Message>::default_instance()
    }
}

impl PingEvent {
    pub fn new() -> PingEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PingEvent| { &m.message_id },
            |m: &mut PingEvent| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &PingEvent| { &m.trace_id },
            |m: &mut PingEvent| { &mut m.trace_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &PingEvent| { &m.node_id },
            |m: &mut PingEvent| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_terminated",
            |m: &PingEvent| { &m.system_terminated },
            |m: &mut PingEvent| { &mut m.system_terminated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingEvent>(
            "PingEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingEvent {
    const NAME: &'static str = "PingEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.trace_id = is.read_string()?;
                },
                24 => {
                    self.node_id = is.read_uint64()?;
                },
                32 => {
                    self.system_terminated = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.node_id);
        }
        if self.system_terminated != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        if self.node_id != 0 {
            os.write_uint64(3, self.node_id)?;
        }
        if self.system_terminated != false {
            os.write_bool(4, self.system_terminated)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingEvent {
        PingEvent::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.trace_id.clear();
        self.node_id = 0;
        self.system_terminated = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingEvent {
        static instance: PingEvent = PingEvent {
            message_id: ::std::string::String::new(),
            trace_id: ::std::string::String::new(),
            node_id: 0,
            system_terminated: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.PongEvent)
pub struct PongEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.PongEvent.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.PongEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.PongEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PongEvent {
    fn default() -> &'a PongEvent {
        <PongEvent as ::protobuf::Message>::default_instance()
    }
}

impl PongEvent {
    pub fn new() -> PongEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PongEvent| { &m.message_id },
            |m: &mut PongEvent| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &PongEvent| { &m.trace_id },
            |m: &mut PongEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PongEvent>(
            "PongEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PongEvent {
    const NAME: &'static str = "PongEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PongEvent {
        PongEvent::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PongEvent {
        static instance: PongEvent = PongEvent {
            message_id: ::std::string::String::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PongEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PongEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PongEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PongEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.CreateActorEvent)
pub struct CreateActorEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.CreateActorEvent.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.CreateActorEvent.actor_id)
    pub actor_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.CreateActorEvent.actor_type)
    pub actor_type: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.CreateActorEvent.recipe)
    pub recipe: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:coerce.network.CreateActorEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.CreateActorEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateActorEvent {
    fn default() -> &'a CreateActorEvent {
        <CreateActorEvent as ::protobuf::Message>::default_instance()
    }
}

impl CreateActorEvent {
    pub fn new() -> CreateActorEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &CreateActorEvent| { &m.message_id },
            |m: &mut CreateActorEvent| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_id",
            |m: &CreateActorEvent| { &m.actor_id },
            |m: &mut CreateActorEvent| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_type",
            |m: &CreateActorEvent| { &m.actor_type },
            |m: &mut CreateActorEvent| { &mut m.actor_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recipe",
            |m: &CreateActorEvent| { &m.recipe },
            |m: &mut CreateActorEvent| { &mut m.recipe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &CreateActorEvent| { &m.trace_id },
            |m: &mut CreateActorEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateActorEvent>(
            "CreateActorEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateActorEvent {
    const NAME: &'static str = "CreateActorEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.actor_id = is.read_string()?;
                },
                26 => {
                    self.actor_type = is.read_string()?;
                },
                34 => {
                    self.recipe = is.read_bytes()?;
                },
                42 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.actor_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_type);
        }
        if !self.recipe.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.recipe);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.actor_type.is_empty() {
            os.write_string(3, &self.actor_type)?;
        }
        if !self.recipe.is_empty() {
            os.write_bytes(4, &self.recipe)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(5, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateActorEvent {
        CreateActorEvent::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.actor_type.clear();
        self.recipe.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateActorEvent {
        static instance: CreateActorEvent = CreateActorEvent {
            message_id: ::std::string::String::new(),
            actor_id: ::std::string::String::new(),
            actor_type: ::std::string::String::new(),
            recipe: ::std::vec::Vec::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateActorEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateActorEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateActorEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateActorEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.FindActorEvent)
pub struct FindActorEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.FindActorEvent.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.FindActorEvent.actor_id)
    pub actor_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.FindActorEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.FindActorEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FindActorEvent {
    fn default() -> &'a FindActorEvent {
        <FindActorEvent as ::protobuf::Message>::default_instance()
    }
}

impl FindActorEvent {
    pub fn new() -> FindActorEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &FindActorEvent| { &m.message_id },
            |m: &mut FindActorEvent| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_id",
            |m: &FindActorEvent| { &m.actor_id },
            |m: &mut FindActorEvent| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &FindActorEvent| { &m.trace_id },
            |m: &mut FindActorEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FindActorEvent>(
            "FindActorEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FindActorEvent {
    const NAME: &'static str = "FindActorEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.actor_id = is.read_string()?;
                },
                26 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FindActorEvent {
        FindActorEvent::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.actor_id.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FindActorEvent {
        static instance: FindActorEvent = FindActorEvent {
            message_id: ::std::string::String::new(),
            actor_id: ::std::string::String::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FindActorEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FindActorEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FindActorEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FindActorEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.ActorAddress)
pub struct ActorAddress {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.ActorAddress.actor_id)
    pub actor_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ActorAddress.node_id)
    pub node_id: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    // @@protoc_insertion_point(field:coerce.network.ActorAddress.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.ActorAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActorAddress {
    fn default() -> &'a ActorAddress {
        <ActorAddress as ::protobuf::Message>::default_instance()
    }
}

impl ActorAddress {
    pub fn new() -> ActorAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_id",
            |m: &ActorAddress| { &m.actor_id },
            |m: &mut ActorAddress| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "node_id",
            |m: &ActorAddress| { &m.node_id },
            |m: &mut ActorAddress| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &ActorAddress| { &m.trace_id },
            |m: &mut ActorAddress| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActorAddress>(
            "ActorAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActorAddress {
    const NAME: &'static str = "ActorAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actor_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node_id)?;
                },
                26 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.actor_id);
        }
        if let Some(v) = self.node_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.actor_id.is_empty() {
            os.write_string(1, &self.actor_id)?;
        }
        if let Some(v) = self.node_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActorAddress {
        ActorAddress::new()
    }

    fn clear(&mut self) {
        self.actor_id.clear();
        self.node_id.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActorAddress {
        static instance: ActorAddress = ActorAddress {
            actor_id: ::std::string::String::new(),
            node_id: ::protobuf::MessageField::none(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActorAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActorAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActorAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.MessageRequest)
pub struct MessageRequest {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.handler_type)
    pub handler_type: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.actor_id)
    pub actor_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.message)
    pub message: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.trace_id)
    pub trace_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.requires_response)
    pub requires_response: bool,
    // @@protoc_insertion_point(field:coerce.network.MessageRequest.origin_node_id)
    pub origin_node_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.MessageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageRequest {
    fn default() -> &'a MessageRequest {
        <MessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageRequest {
    pub fn new() -> MessageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &MessageRequest| { &m.message_id },
            |m: &mut MessageRequest| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handler_type",
            |m: &MessageRequest| { &m.handler_type },
            |m: &mut MessageRequest| { &mut m.handler_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_id",
            |m: &MessageRequest| { &m.actor_id },
            |m: &mut MessageRequest| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &MessageRequest| { &m.message },
            |m: &mut MessageRequest| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &MessageRequest| { &m.trace_id },
            |m: &mut MessageRequest| { &mut m.trace_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_response",
            |m: &MessageRequest| { &m.requires_response },
            |m: &mut MessageRequest| { &mut m.requires_response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "origin_node_id",
            |m: &MessageRequest| { &m.origin_node_id },
            |m: &mut MessageRequest| { &mut m.origin_node_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageRequest>(
            "MessageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageRequest {
    const NAME: &'static str = "MessageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                18 => {
                    self.handler_type = is.read_string()?;
                },
                26 => {
                    self.actor_id = is.read_string()?;
                },
                34 => {
                    self.message = is.read_bytes()?;
                },
                42 => {
                    self.trace_id = is.read_string()?;
                },
                48 => {
                    self.requires_response = is.read_bool()?;
                },
                56 => {
                    self.origin_node_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if !self.handler_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handler_type);
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor_id);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.message);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trace_id);
        }
        if self.requires_response != false {
            my_size += 1 + 1;
        }
        if self.origin_node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.origin_node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if !self.handler_type.is_empty() {
            os.write_string(2, &self.handler_type)?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(3, &self.actor_id)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(4, &self.message)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(5, &self.trace_id)?;
        }
        if self.requires_response != false {
            os.write_bool(6, self.requires_response)?;
        }
        if self.origin_node_id != 0 {
            os.write_uint64(7, self.origin_node_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageRequest {
        MessageRequest::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.handler_type.clear();
        self.actor_id.clear();
        self.message.clear();
        self.trace_id.clear();
        self.requires_response = false;
        self.origin_node_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageRequest {
        static instance: MessageRequest = MessageRequest {
            message_id: ::std::string::String::new(),
            handler_type: ::std::string::String::new(),
            actor_id: ::std::string::String::new(),
            message: ::std::vec::Vec::new(),
            trace_id: ::std::string::String::new(),
            requires_response: false,
            origin_node_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.SessionHandshake)
pub struct SessionHandshake {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.nodes)
    pub nodes: ::std::vec::Vec<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.token)
    pub token: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.node_tag)
    pub node_tag: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.client_type)
    pub client_type: ::protobuf::EnumOrUnknown<ClientType>,
    // @@protoc_insertion_point(field:coerce.network.SessionHandshake.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.SessionHandshake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionHandshake {
    fn default() -> &'a SessionHandshake {
        <SessionHandshake as ::protobuf::Message>::default_instance()
    }
}

impl SessionHandshake {
    pub fn new() -> SessionHandshake {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &SessionHandshake| { &m.node_id },
            |m: &mut SessionHandshake| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &SessionHandshake| { &m.nodes },
            |m: &mut SessionHandshake| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &SessionHandshake| { &m.token },
            |m: &mut SessionHandshake| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_tag",
            |m: &SessionHandshake| { &m.node_tag },
            |m: &mut SessionHandshake| { &mut m.node_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_type",
            |m: &SessionHandshake| { &m.client_type },
            |m: &mut SessionHandshake| { &mut m.client_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &SessionHandshake| { &m.trace_id },
            |m: &mut SessionHandshake| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionHandshake>(
            "SessionHandshake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionHandshake {
    const NAME: &'static str = "SessionHandshake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_uint64()?;
                },
                18 => {
                    self.nodes.push(is.read_message()?);
                },
                26 => {
                    self.token = is.read_bytes()?;
                },
                34 => {
                    self.node_tag = is.read_string()?;
                },
                40 => {
                    self.client_type = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.node_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token);
        }
        if !self.node_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_tag);
        }
        if self.client_type != ::protobuf::EnumOrUnknown::new(ClientType::Client) {
            my_size += ::protobuf::rt::int32_size(5, self.client_type.value());
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.token.is_empty() {
            os.write_bytes(3, &self.token)?;
        }
        if !self.node_tag.is_empty() {
            os.write_string(4, &self.node_tag)?;
        }
        if self.client_type != ::protobuf::EnumOrUnknown::new(ClientType::Client) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.client_type))?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(6, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionHandshake {
        SessionHandshake::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.nodes.clear();
        self.token.clear();
        self.node_tag.clear();
        self.client_type = ::protobuf::EnumOrUnknown::new(ClientType::Client);
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionHandshake {
        static instance: SessionHandshake = SessionHandshake {
            node_id: 0,
            nodes: ::std::vec::Vec::new(),
            token: ::std::vec::Vec::new(),
            node_tag: ::std::string::String::new(),
            client_type: ::protobuf::EnumOrUnknown::from_i32(0),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionHandshake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionHandshake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionHandshake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionHandshake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.StreamPublishEvent)
pub struct StreamPublishEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.StreamPublishEvent.topic)
    pub topic: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.StreamPublishEvent.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.StreamPublishEvent.message)
    pub message: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:coerce.network.StreamPublishEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.StreamPublishEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamPublishEvent {
    fn default() -> &'a StreamPublishEvent {
        <StreamPublishEvent as ::protobuf::Message>::default_instance()
    }
}

impl StreamPublishEvent {
    pub fn new() -> StreamPublishEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "topic",
            |m: &StreamPublishEvent| { &m.topic },
            |m: &mut StreamPublishEvent| { &mut m.topic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &StreamPublishEvent| { &m.key },
            |m: &mut StreamPublishEvent| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &StreamPublishEvent| { &m.message },
            |m: &mut StreamPublishEvent| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &StreamPublishEvent| { &m.trace_id },
            |m: &mut StreamPublishEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamPublishEvent>(
            "StreamPublishEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamPublishEvent {
    const NAME: &'static str = "StreamPublishEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.topic = is.read_string()?;
                },
                18 => {
                    self.key = is.read_string()?;
                },
                26 => {
                    self.message = is.read_bytes()?;
                },
                34 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(4, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamPublishEvent {
        StreamPublishEvent::new()
    }

    fn clear(&mut self) {
        self.topic.clear();
        self.key.clear();
        self.message.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamPublishEvent {
        static instance: StreamPublishEvent = StreamPublishEvent {
            topic: ::std::string::String::new(),
            key: ::std::string::String::new(),
            message: ::std::vec::Vec::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamPublishEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamPublishEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamPublishEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamPublishEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.NewNodeEvent)
pub struct NewNodeEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.NewNodeEvent.node)
    pub node: ::protobuf::MessageField<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.NewNodeEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.NewNodeEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NewNodeEvent {
    fn default() -> &'a NewNodeEvent {
        <NewNodeEvent as ::protobuf::Message>::default_instance()
    }
}

impl NewNodeEvent {
    pub fn new() -> NewNodeEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteNode>(
            "node",
            |m: &NewNodeEvent| { &m.node },
            |m: &mut NewNodeEvent| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &NewNodeEvent| { &m.trace_id },
            |m: &mut NewNodeEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NewNodeEvent>(
            "NewNodeEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NewNodeEvent {
    const NAME: &'static str = "NewNodeEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node)?;
                },
                18 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.node.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NewNodeEvent {
        NewNodeEvent::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NewNodeEvent {
        static instance: NewNodeEvent = NewNodeEvent {
            node: ::protobuf::MessageField::none(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NewNodeEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NewNodeEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NewNodeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewNodeEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.NodeRemovedEvent)
pub struct NodeRemovedEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.NodeRemovedEvent.node)
    pub node: ::protobuf::MessageField<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.NodeRemovedEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.NodeRemovedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeRemovedEvent {
    fn default() -> &'a NodeRemovedEvent {
        <NodeRemovedEvent as ::protobuf::Message>::default_instance()
    }
}

impl NodeRemovedEvent {
    pub fn new() -> NodeRemovedEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteNode>(
            "node",
            |m: &NodeRemovedEvent| { &m.node },
            |m: &mut NodeRemovedEvent| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &NodeRemovedEvent| { &m.trace_id },
            |m: &mut NodeRemovedEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeRemovedEvent>(
            "NodeRemovedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeRemovedEvent {
    const NAME: &'static str = "NodeRemovedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.node)?;
                },
                18 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.node.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeRemovedEvent {
        NodeRemovedEvent::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeRemovedEvent {
        static instance: NodeRemovedEvent = NodeRemovedEvent {
            node: ::protobuf::MessageField::none(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeRemovedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeRemovedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeRemovedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeRemovedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.LeaderChangedEvent)
pub struct LeaderChangedEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.LeaderChangedEvent.node_id)
    pub node_id: u64,
    // @@protoc_insertion_point(field:coerce.network.LeaderChangedEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.LeaderChangedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LeaderChangedEvent {
    fn default() -> &'a LeaderChangedEvent {
        <LeaderChangedEvent as ::protobuf::Message>::default_instance()
    }
}

impl LeaderChangedEvent {
    pub fn new() -> LeaderChangedEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &LeaderChangedEvent| { &m.node_id },
            |m: &mut LeaderChangedEvent| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &LeaderChangedEvent| { &m.trace_id },
            |m: &mut LeaderChangedEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LeaderChangedEvent>(
            "LeaderChangedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LeaderChangedEvent {
    const NAME: &'static str = "LeaderChangedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_uint64()?;
                },
                18 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.node_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_uint64(1, self.node_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_string(2, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LeaderChangedEvent {
        LeaderChangedEvent::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LeaderChangedEvent {
        static instance: LeaderChangedEvent = LeaderChangedEvent {
            node_id: 0,
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LeaderChangedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LeaderChangedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LeaderChangedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaderChangedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.MemberUpEvent)
pub struct MemberUpEvent {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.MemberUpEvent.leader_id)
    pub leader_id: u64,
    // @@protoc_insertion_point(field:coerce.network.MemberUpEvent.nodes)
    pub nodes: ::std::vec::Vec<RemoteNode>,
    // @@protoc_insertion_point(field:coerce.network.MemberUpEvent.trace_id)
    pub trace_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.MemberUpEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MemberUpEvent {
    fn default() -> &'a MemberUpEvent {
        <MemberUpEvent as ::protobuf::Message>::default_instance()
    }
}

impl MemberUpEvent {
    pub fn new() -> MemberUpEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "leader_id",
            |m: &MemberUpEvent| { &m.leader_id },
            |m: &mut MemberUpEvent| { &mut m.leader_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &MemberUpEvent| { &m.nodes },
            |m: &mut MemberUpEvent| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &MemberUpEvent| { &m.trace_id },
            |m: &mut MemberUpEvent| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemberUpEvent>(
            "MemberUpEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MemberUpEvent {
    const NAME: &'static str = "MemberUpEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.leader_id = is.read_uint64()?;
                },
                18 => {
                    self.nodes.push(is.read_message()?);
                },
                26 => {
                    self.trace_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.leader_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.leader_id != 0 {
            os.write_uint64(1, self.leader_id)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.trace_id.is_empty() {
            os.write_string(3, &self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MemberUpEvent {
        MemberUpEvent::new()
    }

    fn clear(&mut self) {
        self.leader_id = 0;
        self.nodes.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MemberUpEvent {
        static instance: MemberUpEvent = MemberUpEvent {
            leader_id: 0,
            nodes: ::std::vec::Vec::new(),
            trace_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MemberUpEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MemberUpEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MemberUpEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberUpEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.RaftRequest)
pub struct RaftRequest {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.RaftRequest.message_id)
    pub message_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.RaftRequest.request_type)
    pub request_type: u32,
    // @@protoc_insertion_point(field:coerce.network.RaftRequest.payload)
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.RaftRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RaftRequest {
    fn default() -> &'a RaftRequest {
        <RaftRequest as ::protobuf::Message>::default_instance()
    }
}

impl RaftRequest {
    pub fn new() -> RaftRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &RaftRequest| { &m.message_id },
            |m: &mut RaftRequest| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type",
            |m: &RaftRequest| { &m.request_type },
            |m: &mut RaftRequest| { &mut m.request_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &RaftRequest| { &m.payload },
            |m: &mut RaftRequest| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RaftRequest>(
            "RaftRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RaftRequest {
    const NAME: &'static str = "RaftRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_id = is.read_string()?;
                },
                16 => {
                    self.request_type = is.read_uint32()?;
                },
                26 => {
                    self.payload = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message_id);
        }
        if self.request_type != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.request_type);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.message_id.is_empty() {
            os.write_string(1, &self.message_id)?;
        }
        if self.request_type != 0 {
            os.write_uint32(2, self.request_type)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RaftRequest {
        RaftRequest::new()
    }

    fn clear(&mut self) {
        self.message_id.clear();
        self.request_type = 0;
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RaftRequest {
        static instance: RaftRequest = RaftRequest {
            message_id: ::std::string::String::new(),
            request_type: 0,
            payload: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RaftRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RaftRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RaftRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RaftRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:coerce.network.ActorRefErr)
pub struct ActorRefErr {
    // message fields
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.type)
    pub type_: ::protobuf::EnumOrUnknown<actor_ref_err::ErrorType>,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.actor_id)
    pub actor_id: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.message_type)
    pub message_type: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.actor_type)
    pub actor_type: ::std::string::String,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.time_taken_millis)
    pub time_taken_millis: u64,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.serialization_error)
    pub serialization_error: ::protobuf::EnumOrUnknown<MessageWrapErr>,
    // @@protoc_insertion_point(field:coerce.network.ActorRefErr.deserialization_error)
    pub deserialization_error: ::protobuf::EnumOrUnknown<MessageUnwrapErr>,
    // special fields
    // @@protoc_insertion_point(special_field:coerce.network.ActorRefErr.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActorRefErr {
    fn default() -> &'a ActorRefErr {
        <ActorRefErr as ::protobuf::Message>::default_instance()
    }
}

impl ActorRefErr {
    pub fn new() -> ActorRefErr {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ActorRefErr| { &m.type_ },
            |m: &mut ActorRefErr| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_id",
            |m: &ActorRefErr| { &m.actor_id },
            |m: &mut ActorRefErr| { &mut m.actor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_type",
            |m: &ActorRefErr| { &m.message_type },
            |m: &mut ActorRefErr| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actor_type",
            |m: &ActorRefErr| { &m.actor_type },
            |m: &mut ActorRefErr| { &mut m.actor_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_taken_millis",
            |m: &ActorRefErr| { &m.time_taken_millis },
            |m: &mut ActorRefErr| { &mut m.time_taken_millis },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "serialization_error",
            |m: &ActorRefErr| { &m.serialization_error },
            |m: &mut ActorRefErr| { &mut m.serialization_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deserialization_error",
            |m: &ActorRefErr| { &m.deserialization_error },
            |m: &mut ActorRefErr| { &mut m.deserialization_error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActorRefErr>(
            "ActorRefErr",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActorRefErr {
    const NAME: &'static str = "ActorRefErr";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.actor_id = is.read_string()?;
                },
                26 => {
                    self.message_type = is.read_string()?;
                },
                34 => {
                    self.actor_type = is.read_string()?;
                },
                40 => {
                    self.time_taken_millis = is.read_uint64()?;
                },
                48 => {
                    self.serialization_error = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.deserialization_error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(actor_ref_err::ErrorType::ActorUnavailable) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.actor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actor_id);
        }
        if !self.message_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message_type);
        }
        if !self.actor_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.actor_type);
        }
        if self.time_taken_millis != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.time_taken_millis);
        }
        if self.serialization_error != ::protobuf::EnumOrUnknown::new(MessageWrapErr::UnknownWrapErr) {
            my_size += ::protobuf::rt::int32_size(6, self.serialization_error.value());
        }
        if self.deserialization_error != ::protobuf::EnumOrUnknown::new(MessageUnwrapErr::UnknownUnwrapErr) {
            my_size += ::protobuf::rt::int32_size(7, self.deserialization_error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(actor_ref_err::ErrorType::ActorUnavailable) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.actor_id.is_empty() {
            os.write_string(2, &self.actor_id)?;
        }
        if !self.message_type.is_empty() {
            os.write_string(3, &self.message_type)?;
        }
        if !self.actor_type.is_empty() {
            os.write_string(4, &self.actor_type)?;
        }
        if self.time_taken_millis != 0 {
            os.write_uint64(5, self.time_taken_millis)?;
        }
        if self.serialization_error != ::protobuf::EnumOrUnknown::new(MessageWrapErr::UnknownWrapErr) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.serialization_error))?;
        }
        if self.deserialization_error != ::protobuf::EnumOrUnknown::new(MessageUnwrapErr::UnknownUnwrapErr) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.deserialization_error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActorRefErr {
        ActorRefErr::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(actor_ref_err::ErrorType::ActorUnavailable);
        self.actor_id.clear();
        self.message_type.clear();
        self.actor_type.clear();
        self.time_taken_millis = 0;
        self.serialization_error = ::protobuf::EnumOrUnknown::new(MessageWrapErr::UnknownWrapErr);
        self.deserialization_error = ::protobuf::EnumOrUnknown::new(MessageUnwrapErr::UnknownUnwrapErr);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActorRefErr {
        static instance: ActorRefErr = ActorRefErr {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            actor_id: ::std::string::String::new(),
            message_type: ::std::string::String::new(),
            actor_type: ::std::string::String::new(),
            time_taken_millis: 0,
            serialization_error: ::protobuf::EnumOrUnknown::from_i32(0),
            deserialization_error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActorRefErr {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActorRefErr").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActorRefErr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorRefErr {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActorRefErr`
pub mod actor_ref_err {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:coerce.network.ActorRefErr.ErrorType)
    pub enum ErrorType {
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.ActorUnavailable)
        ActorUnavailable = 0,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.NotFound)
        NotFound = 1,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.AlreadyExists)
        AlreadyExists = 2,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.Serialisation)
        Serialisation = 3,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.Deserialisation)
        Deserialisation = 4,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.Timeout)
        Timeout = 5,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.ActorStartFailed)
        ActorStartFailed = 6,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.InvalidRef)
        InvalidRef = 7,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.ResultChannelClosed)
        ResultChannelClosed = 8,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.ResultSendFailed)
        ResultSendFailed = 9,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.NotSupported)
        NotSupported = 10,
        // @@protoc_insertion_point(enum_value:coerce.network.ActorRefErr.ErrorType.NotImplemented)
        NotImplemented = 11,
    }

    impl ::protobuf::Enum for ErrorType {
        const NAME: &'static str = "ErrorType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ErrorType> {
            match value {
                0 => ::std::option::Option::Some(ErrorType::ActorUnavailable),
                1 => ::std::option::Option::Some(ErrorType::NotFound),
                2 => ::std::option::Option::Some(ErrorType::AlreadyExists),
                3 => ::std::option::Option::Some(ErrorType::Serialisation),
                4 => ::std::option::Option::Some(ErrorType::Deserialisation),
                5 => ::std::option::Option::Some(ErrorType::Timeout),
                6 => ::std::option::Option::Some(ErrorType::ActorStartFailed),
                7 => ::std::option::Option::Some(ErrorType::InvalidRef),
                8 => ::std::option::Option::Some(ErrorType::ResultChannelClosed),
                9 => ::std::option::Option::Some(ErrorType::ResultSendFailed),
                10 => ::std::option::Option::Some(ErrorType::NotSupported),
                11 => ::std::option::Option::Some(ErrorType::NotImplemented),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ErrorType] = &[
            ErrorType::ActorUnavailable,
            ErrorType::NotFound,
            ErrorType::AlreadyExists,
            ErrorType::Serialisation,
            ErrorType::Deserialisation,
            ErrorType::Timeout,
            ErrorType::ActorStartFailed,
            ErrorType::InvalidRef,
            ErrorType::ResultChannelClosed,
            ErrorType::ResultSendFailed,
            ErrorType::NotSupported,
            ErrorType::NotImplemented,
        ];
    }

    impl ::protobuf::EnumFull for ErrorType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActorRefErr.ErrorType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ErrorType {
        fn default() -> Self {
            ErrorType::ActorUnavailable
        }
    }

    impl ErrorType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorType>("ActorRefErr.ErrorType")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:coerce.network.Event)
pub enum Event {
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Identify)
    Identify = 0,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Handshake)
    Handshake = 1,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Result)
    Result = 2,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Err)
    Err = 3,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Ping)
    Ping = 4,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Pong)
    Pong = 5,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.CreateActor)
    CreateActor = 6,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.FindActor)
    FindActor = 7,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.RegisterActor)
    RegisterActor = 8,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.NotifyActor)
    NotifyActor = 9,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.StreamPublish)
    StreamPublish = 10,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Raft)
    Raft = 11,
    // @@protoc_insertion_point(enum_value:coerce.network.Event.Identity)
    Identity = 12,
}

impl ::protobuf::Enum for Event {
    const NAME: &'static str = "Event";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event> {
        match value {
            0 => ::std::option::Option::Some(Event::Identify),
            1 => ::std::option::Option::Some(Event::Handshake),
            2 => ::std::option::Option::Some(Event::Result),
            3 => ::std::option::Option::Some(Event::Err),
            4 => ::std::option::Option::Some(Event::Ping),
            5 => ::std::option::Option::Some(Event::Pong),
            6 => ::std::option::Option::Some(Event::CreateActor),
            7 => ::std::option::Option::Some(Event::FindActor),
            8 => ::std::option::Option::Some(Event::RegisterActor),
            9 => ::std::option::Option::Some(Event::NotifyActor),
            10 => ::std::option::Option::Some(Event::StreamPublish),
            11 => ::std::option::Option::Some(Event::Raft),
            12 => ::std::option::Option::Some(Event::Identity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Event] = &[
        Event::Identify,
        Event::Handshake,
        Event::Result,
        Event::Err,
        Event::Ping,
        Event::Pong,
        Event::CreateActor,
        Event::FindActor,
        Event::RegisterActor,
        Event::NotifyActor,
        Event::StreamPublish,
        Event::Raft,
        Event::Identity,
    ];
}

impl ::protobuf::EnumFull for Event {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Event").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Event {
    fn default() -> Self {
        Event::Identify
    }
}

impl Event {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Event>("Event")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:coerce.network.ClientType)
pub enum ClientType {
    // @@protoc_insertion_point(enum_value:coerce.network.ClientType.Client)
    Client = 0,
    // @@protoc_insertion_point(enum_value:coerce.network.ClientType.Worker)
    Worker = 1,
}

impl ::protobuf::Enum for ClientType {
    const NAME: &'static str = "ClientType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            0 => ::std::option::Option::Some(ClientType::Client),
            1 => ::std::option::Option::Some(ClientType::Worker),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClientType] = &[
        ClientType::Client,
        ClientType::Worker,
    ];
}

impl ::protobuf::EnumFull for ClientType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClientType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::Client
    }
}

impl ClientType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientType>("ClientType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:coerce.network.SystemEvent)
pub enum SystemEvent {
    // @@protoc_insertion_point(enum_value:coerce.network.SystemEvent.ClusterNewNode)
    ClusterNewNode = 0,
    // @@protoc_insertion_point(enum_value:coerce.network.SystemEvent.ClusterNodeRemoved)
    ClusterNodeRemoved = 1,
    // @@protoc_insertion_point(enum_value:coerce.network.SystemEvent.ClusterLeaderChanged)
    ClusterLeaderChanged = 2,
    // @@protoc_insertion_point(enum_value:coerce.network.SystemEvent.ClusterMemberUp)
    ClusterMemberUp = 3,
}

impl ::protobuf::Enum for SystemEvent {
    const NAME: &'static str = "SystemEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SystemEvent> {
        match value {
            0 => ::std::option::Option::Some(SystemEvent::ClusterNewNode),
            1 => ::std::option::Option::Some(SystemEvent::ClusterNodeRemoved),
            2 => ::std::option::Option::Some(SystemEvent::ClusterLeaderChanged),
            3 => ::std::option::Option::Some(SystemEvent::ClusterMemberUp),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SystemEvent] = &[
        SystemEvent::ClusterNewNode,
        SystemEvent::ClusterNodeRemoved,
        SystemEvent::ClusterLeaderChanged,
        SystemEvent::ClusterMemberUp,
    ];
}

impl ::protobuf::EnumFull for SystemEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SystemEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SystemEvent {
    fn default() -> Self {
        SystemEvent::ClusterNewNode
    }
}

impl SystemEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SystemEvent>("SystemEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:coerce.network.MessageUnwrapErr)
pub enum MessageUnwrapErr {
    // @@protoc_insertion_point(enum_value:coerce.network.MessageUnwrapErr.UnknownUnwrapErr)
    UnknownUnwrapErr = 0,
    // @@protoc_insertion_point(enum_value:coerce.network.MessageUnwrapErr.UnwrapUnsupported)
    UnwrapUnsupported = 1,
    // @@protoc_insertion_point(enum_value:coerce.network.MessageUnwrapErr.DeserializationErr)
    DeserializationErr = 2,
}

impl ::protobuf::Enum for MessageUnwrapErr {
    const NAME: &'static str = "MessageUnwrapErr";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageUnwrapErr> {
        match value {
            0 => ::std::option::Option::Some(MessageUnwrapErr::UnknownUnwrapErr),
            1 => ::std::option::Option::Some(MessageUnwrapErr::UnwrapUnsupported),
            2 => ::std::option::Option::Some(MessageUnwrapErr::DeserializationErr),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageUnwrapErr] = &[
        MessageUnwrapErr::UnknownUnwrapErr,
        MessageUnwrapErr::UnwrapUnsupported,
        MessageUnwrapErr::DeserializationErr,
    ];
}

impl ::protobuf::EnumFull for MessageUnwrapErr {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageUnwrapErr").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MessageUnwrapErr {
    fn default() -> Self {
        MessageUnwrapErr::UnknownUnwrapErr
    }
}

impl MessageUnwrapErr {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageUnwrapErr>("MessageUnwrapErr")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:coerce.network.MessageWrapErr)
pub enum MessageWrapErr {
    // @@protoc_insertion_point(enum_value:coerce.network.MessageWrapErr.UnknownWrapErr)
    UnknownWrapErr = 0,
    // @@protoc_insertion_point(enum_value:coerce.network.MessageWrapErr.WrapUnsupported)
    WrapUnsupported = 1,
    // @@protoc_insertion_point(enum_value:coerce.network.MessageWrapErr.SerializationErr)
    SerializationErr = 2,
}

impl ::protobuf::Enum for MessageWrapErr {
    const NAME: &'static str = "MessageWrapErr";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageWrapErr> {
        match value {
            0 => ::std::option::Option::Some(MessageWrapErr::UnknownWrapErr),
            1 => ::std::option::Option::Some(MessageWrapErr::WrapUnsupported),
            2 => ::std::option::Option::Some(MessageWrapErr::SerializationErr),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageWrapErr] = &[
        MessageWrapErr::UnknownWrapErr,
        MessageWrapErr::WrapUnsupported,
        MessageWrapErr::SerializationErr,
    ];
}

impl ::protobuf::EnumFull for MessageWrapErr {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageWrapErr").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MessageWrapErr {
    fn default() -> Self {
        MessageWrapErr::UnknownWrapErr
    }
}

impl MessageWrapErr {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageWrapErr>("MessageWrapErr")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rnetwork.proto\x12\x0ecoerce.network\x1a\x1egoogle/protobuf/wrappers.\
    proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x9a\x02\n\nRemoteNode\x12\
    \x17\n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeId\x12\x12\n\x04addr\x18\
    \x02\x20\x01(\tR\x04addr\x12B\n\x0fnode_started_at\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\rnodeStartedAt\x12\x10\n\x03tag\x18\x04\
    \x20\x01(\tR\x03tag\x12J\n\nattributes\x18\x05\x20\x03(\x0b2*.coerce.net\
    work.RemoteNode.AttributesEntryR\nattributes\x1a=\n\x0fAttributesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"s\n\rIdentifyEvent\x12$\n\x0esource_nod\
    e_id\x18\x01\x20\x01(\x04R\x0csourceNodeId\x12&\n\x0fsource_node_tag\x18\
    \x02\x20\x01(\tR\rsourceNodeTag\x12\x14\n\x05token\x18\x03\x20\x01(\tR\
    \x05token\"\xfd\x03\n\x0cNodeIdentity\x12\x17\n\x07node_id\x18\x01\x20\
    \x01(\x04R\x06nodeId\x12\x19\n\x08node_tag\x18\x02\x20\x01(\tR\x07nodeTa\
    g\x12\x12\n\x04addr\x18\x03\x20\x01(\tR\x04addr\x12/\n\x13application_ve\
    rsion\x18\x04\x20\x01(\tR\x12applicationVersion\x12)\n\x10protocol_versi\
    on\x18\x05\x20\x01(\tR\x0fprotocolVersion\x12B\n\x0fnode_started_at\x18\
    \x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\rnodeStartedAt\x120\n\
    \x05peers\x18\x07\x20\x03(\x0b2\x1a.coerce.network.RemoteNodeR\x05peers\
    \x12F\n\x0ccapabilities\x18\x08\x20\x01(\x0b2\".coerce.network.SystemCap\
    abilitiesR\x0ccapabilities\x12L\n\nattributes\x18\t\x20\x03(\x0b2,.coerc\
    e.network.NodeIdentity.AttributesEntryR\nattributes\x1a=\n\x0fAttributes\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"H\n\x12SystemCapabilities\x12\x16\n\
    \x06actors\x18\x01\x20\x03(\tR\x06actors\x12\x1a\n\x08messages\x18\x02\
    \x20\x03(\tR\x08messages\"\xd6\x01\n\x0fClientHandshake\x12\x17\n\x07nod\
    e_id\x18\x01\x20\x01(\x04R\x06nodeId\x120\n\x05nodes\x18\x02\x20\x03(\
    \x0b2\x1a.coerce.network.RemoteNodeR\x05nodes\x12\x19\n\x08node_tag\x18\
    \x03\x20\x01(\tR\x07nodeTag\x12\x19\n\x08trace_id\x18\x04\x20\x01(\tR\
    \x07traceId\x12B\n\x0fnode_started_at\x18\x05\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\rnodeStartedAt\"`\n\x0cClientResult\x12\x1d\n\nmessag\
    e_id\x18\x01\x20\x01(\tR\tmessageId\x12\x16\n\x06result\x18\x02\x20\x01(\
    \x0cR\x06result\x12\x19\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceId\"x\
    \n\tClientErr\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageId\x121\
    \n\x05error\x18\x02\x20\x01(\x0b2\x1b.coerce.network.ActorRefErrR\x05err\
    or\x12\x19\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceId\"\x8b\x01\n\tPin\
    gEvent\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageId\x12\x19\n\
    \x08trace_id\x18\x02\x20\x01(\tR\x07traceId\x12\x17\n\x07node_id\x18\x03\
    \x20\x01(\x04R\x06nodeId\x12+\n\x11system_terminated\x18\x04\x20\x01(\
    \x08R\x10systemTerminated\"E\n\tPongEvent\x12\x1d\n\nmessage_id\x18\x01\
    \x20\x01(\tR\tmessageId\x12\x19\n\x08trace_id\x18\x02\x20\x01(\tR\x07tra\
    ceId\"\x9e\x01\n\x10CreateActorEvent\x12\x1d\n\nmessage_id\x18\x01\x20\
    \x01(\tR\tmessageId\x12\x19\n\x08actor_id\x18\x02\x20\x01(\tR\x07actorId\
    \x12\x1d\n\nactor_type\x18\x03\x20\x01(\tR\tactorType\x12\x16\n\x06recip\
    e\x18\x04\x20\x01(\x0cR\x06recipe\x12\x19\n\x08trace_id\x18\x05\x20\x01(\
    \tR\x07traceId\"e\n\x0eFindActorEvent\x12\x1d\n\nmessage_id\x18\x01\x20\
    \x01(\tR\tmessageId\x12\x19\n\x08actor_id\x18\x02\x20\x01(\tR\x07actorId\
    \x12\x19\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceId\"{\n\x0cActorAddre\
    ss\x12\x19\n\x08actor_id\x18\x01\x20\x01(\tR\x07actorId\x125\n\x07node_i\
    d\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x06nodeId\x12\
    \x19\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceId\"\xf5\x01\n\x0eMessage\
    Request\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageId\x12!\n\x0ch\
    andler_type\x18\x02\x20\x01(\tR\x0bhandlerType\x12\x19\n\x08actor_id\x18\
    \x03\x20\x01(\tR\x07actorId\x12\x18\n\x07message\x18\x04\x20\x01(\x0cR\
    \x07message\x12\x19\n\x08trace_id\x18\x05\x20\x01(\tR\x07traceId\x12+\n\
    \x11requires_response\x18\x06\x20\x01(\x08R\x10requiresResponse\x12$\n\
    \x0eorigin_node_id\x18\x07\x20\x01(\x04R\x0coriginNodeId\"\xe6\x01\n\x10\
    SessionHandshake\x12\x17\n\x07node_id\x18\x01\x20\x01(\x04R\x06nodeId\
    \x120\n\x05nodes\x18\x02\x20\x03(\x0b2\x1a.coerce.network.RemoteNodeR\
    \x05nodes\x12\x14\n\x05token\x18\x03\x20\x01(\x0cR\x05token\x12\x19\n\
    \x08node_tag\x18\x04\x20\x01(\tR\x07nodeTag\x12;\n\x0bclient_type\x18\
    \x05\x20\x01(\x0e2\x1a.coerce.network.ClientTypeR\nclientType\x12\x19\n\
    \x08trace_id\x18\x06\x20\x01(\tR\x07traceId\"q\n\x12StreamPublishEvent\
    \x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12\x10\n\x03key\x18\
    \x02\x20\x01(\tR\x03key\x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\x07me\
    ssage\x12\x19\n\x08trace_id\x18\x04\x20\x01(\tR\x07traceId\"Y\n\x0cNewNo\
    deEvent\x12.\n\x04node\x18\x01\x20\x01(\x0b2\x1a.coerce.network.RemoteNo\
    deR\x04node\x12\x19\n\x08trace_id\x18\x02\x20\x01(\tR\x07traceId\"]\n\
    \x10NodeRemovedEvent\x12.\n\x04node\x18\x01\x20\x01(\x0b2\x1a.coerce.net\
    work.RemoteNodeR\x04node\x12\x19\n\x08trace_id\x18\x02\x20\x01(\tR\x07tr\
    aceId\"H\n\x12LeaderChangedEvent\x12\x17\n\x07node_id\x18\x01\x20\x01(\
    \x04R\x06nodeId\x12\x19\n\x08trace_id\x18\x02\x20\x01(\tR\x07traceId\"y\
    \n\rMemberUpEvent\x12\x1b\n\tleader_id\x18\x01\x20\x01(\x04R\x08leaderId\
    \x120\n\x05nodes\x18\x02\x20\x03(\x0b2\x1a.coerce.network.RemoteNodeR\
    \x05nodes\x12\x19\n\x08trace_id\x18\x03\x20\x01(\tR\x07traceId\"i\n\x0bR\
    aftRequest\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\tR\tmessageId\x12!\n\
    \x0crequest_type\x18\x02\x20\x01(\rR\x0brequestType\x12\x18\n\x07payload\
    \x18\x03\x20\x01(\x0cR\x07payload\"\xee\x04\n\x0bActorRefErr\x129\n\x04t\
    ype\x18\x01\x20\x01(\x0e2%.coerce.network.ActorRefErr.ErrorTypeR\x04type\
    \x12\x19\n\x08actor_id\x18\x02\x20\x01(\tR\x07actorId\x12!\n\x0cmessage_\
    type\x18\x03\x20\x01(\tR\x0bmessageType\x12\x1d\n\nactor_type\x18\x04\
    \x20\x01(\tR\tactorType\x12*\n\x11time_taken_millis\x18\x05\x20\x01(\x04\
    R\x0ftimeTakenMillis\x12O\n\x13serialization_error\x18\x06\x20\x01(\x0e2\
    \x1e.coerce.network.MessageWrapErrR\x12serializationError\x12U\n\x15dese\
    rialization_error\x18\x07\x20\x01(\x0e2\x20.coerce.network.MessageUnwrap\
    ErrR\x14deserializationError\"\xf2\x01\n\tErrorType\x12\x14\n\x10ActorUn\
    available\x10\0\x12\x0c\n\x08NotFound\x10\x01\x12\x11\n\rAlreadyExists\
    \x10\x02\x12\x11\n\rSerialisation\x10\x03\x12\x13\n\x0fDeserialisation\
    \x10\x04\x12\x0b\n\x07Timeout\x10\x05\x12\x14\n\x10ActorStartFailed\x10\
    \x06\x12\x0e\n\nInvalidRef\x10\x07\x12\x17\n\x13ResultChannelClosed\x10\
    \x08\x12\x14\n\x10ResultSendFailed\x10\t\x12\x10\n\x0cNotSupported\x10\n\
    \x12\x12\n\x0eNotImplemented\x10\x0b*\xbc\x01\n\x05Event\x12\x0c\n\x08Id\
    entify\x10\0\x12\r\n\tHandshake\x10\x01\x12\n\n\x06Result\x10\x02\x12\
    \x07\n\x03Err\x10\x03\x12\x08\n\x04Ping\x10\x04\x12\x08\n\x04Pong\x10\
    \x05\x12\x0f\n\x0bCreateActor\x10\x06\x12\r\n\tFindActor\x10\x07\x12\x11\
    \n\rRegisterActor\x10\x08\x12\x0f\n\x0bNotifyActor\x10\t\x12\x11\n\rStre\
    amPublish\x10\n\x12\x08\n\x04Raft\x10\x0b\x12\x0c\n\x08Identity\x10\x0c*\
    $\n\nClientType\x12\n\n\x06Client\x10\0\x12\n\n\x06Worker\x10\x01*h\n\
    \x0bSystemEvent\x12\x12\n\x0eClusterNewNode\x10\0\x12\x16\n\x12ClusterNo\
    deRemoved\x10\x01\x12\x18\n\x14ClusterLeaderChanged\x10\x02\x12\x13\n\
    \x0fClusterMemberUp\x10\x03*W\n\x10MessageUnwrapErr\x12\x14\n\x10Unknown\
    UnwrapErr\x10\0\x12\x15\n\x11UnwrapUnsupported\x10\x01\x12\x16\n\x12Dese\
    rializationErr\x10\x02*O\n\x0eMessageWrapErr\x12\x12\n\x0eUnknownWrapErr\
    \x10\0\x12\x13\n\x0fWrapUnsupported\x10\x01\x12\x14\n\x10SerializationEr\
    r\x10\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::wrappers::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(RemoteNode::generated_message_descriptor_data());
            messages.push(IdentifyEvent::generated_message_descriptor_data());
            messages.push(NodeIdentity::generated_message_descriptor_data());
            messages.push(SystemCapabilities::generated_message_descriptor_data());
            messages.push(ClientHandshake::generated_message_descriptor_data());
            messages.push(ClientResult::generated_message_descriptor_data());
            messages.push(ClientErr::generated_message_descriptor_data());
            messages.push(PingEvent::generated_message_descriptor_data());
            messages.push(PongEvent::generated_message_descriptor_data());
            messages.push(CreateActorEvent::generated_message_descriptor_data());
            messages.push(FindActorEvent::generated_message_descriptor_data());
            messages.push(ActorAddress::generated_message_descriptor_data());
            messages.push(MessageRequest::generated_message_descriptor_data());
            messages.push(SessionHandshake::generated_message_descriptor_data());
            messages.push(StreamPublishEvent::generated_message_descriptor_data());
            messages.push(NewNodeEvent::generated_message_descriptor_data());
            messages.push(NodeRemovedEvent::generated_message_descriptor_data());
            messages.push(LeaderChangedEvent::generated_message_descriptor_data());
            messages.push(MemberUpEvent::generated_message_descriptor_data());
            messages.push(RaftRequest::generated_message_descriptor_data());
            messages.push(ActorRefErr::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(Event::generated_enum_descriptor_data());
            enums.push(ClientType::generated_enum_descriptor_data());
            enums.push(SystemEvent::generated_enum_descriptor_data());
            enums.push(MessageUnwrapErr::generated_enum_descriptor_data());
            enums.push(MessageWrapErr::generated_enum_descriptor_data());
            enums.push(actor_ref_err::ErrorType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
